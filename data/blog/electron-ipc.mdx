---
title: Electron 进程间通信
date: '2024-5-8'
tags: ['electron']
draft: false
summary: '上下文隔离（Context Isolation）是一项功能，可确保你的 `preload` 脚本和 Electron 的内部逻辑都在一个独立的上下文中运行，而不是在 webContents 加载的网站中。'
---

进程间通信（IPC）是使用 Electron 构建功能丰富的桌面应用程序的关键部分。由于在 Electron 的进程模型中，主进程和渲染进程的职责不同，因此 IPC 是执行许多常见任务的唯一方式，例如从用户界面调用本地 API 或从本地菜单触发网页内容更改。

### IPC 通道

在 Electron 中，进程间通过开发者定义的 "通道 "与 `ipcMain` 和 `ipcRenderer` 模块传递消息。这些通道的名称是任意的（你可以给它们起任何名字），并且是双向的（你可以在两个模块中使用相同的通道名）。

### 模式1：渲染进程到主进程（单向）

要从渲染进程向主进程发送单向 IPC 消息，可以使用 `ipcRenderer.send` API 发送消息，然后由 `ipcMain.on` API 接收。

您通常使用这种模式从网页内容中调用主进程 API。我们将通过创建一个能以编程方式更改窗口标题的简单应用程序来演示这种模式。

在此演示中，您需要在主进程、呈现器进程和预加载脚本中添加代码。完整代码如下，但我们将在下面的章节中逐一解释每个文件。

### 模式2：渲染进程到主进程（双向）

双向 IPC 的常见应用是从渲染进程代码中调用主进程模块并等待结果。这可以通过使用与 `ipcMain.handle` 搭配使用的 `ipcRenderer.invoke` 来实现。

在下面的示例中，我们将从呈现器进程中打开一个本地文件对话框，并返回所选文件的路径。

在这个演示中，你需要在主进程、呈现器进程和预加载脚本中添加代码。完整的代码如下，但我们会在下面的章节中逐一解释每个文件。

### 模式3：主进程到渲染进程

从主进程向渲染进程发送消息时，需要指定接收消息的渲染进程。消息需要通过渲染进程的 `WebContents` 实例发送到渲染进程。该 `WebContents` 实例包含一个发送方法，其使用方法与 ipcRenderer.send 相同。

为了演示这种模式，我们将创建一个由本地操作系统菜单控制的数字计数器。

在这个演示中，你需要在主进程、呈现器进程和预加载脚本中添加代码。完整代码如下，但我们将在以下章节中逐一解释每个文件。

### 模式4：渲染进程到渲染进程

在 Electron 中，无法使用 `ipcMain` 和 `ipcRenderer` 模块在渲染进程间直接发送信息。为此，你有两种选择：

- 使用主进程作为渲染进程之间的消息中介。这需要将一个渲染进程的消息发送到主进程，主进程再将消息转发给另一个渲染进程。

- 从主进程向两个渲染进程传递 `MessagePort`。这将允许渲染进程在初始设置后直接进行通信。

### 对象序列化

Electron 的 IPC 实现使用 HTML 标准的结构化克隆算法（Structured Clone Algorithm）来序列化进程间传递的对象，这意味着只有特定类型的对象可以通过 IPC 通道传递。

特别是，DOM 对象（如 Element、Location 和 DOMMatrix）、由 C++ 类支持的 Node.js 对象（如 process.env、Stream 的某些成员），以及由 C++ 类支持的 Electron 对象（如 WebContents、BrowserWindow 和 WebFrame），都不能通过结构化克隆进行序列化。